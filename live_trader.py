"""
Live trader for BTC 15-min Up/Down markets.
Same strategy as paper_trader, but places real orders via py-clob-client.

Usage: python -u live_trader.py
Stop:  Ctrl+C (prints session summary)

REQUIRES .env with:
  POLY_API_KEY, POLY_API_SECRET, POLY_API_PASSPHRASE, POLY_PRIVATE_KEY, POLY_FUNDER
"""
import asyncio
import json
import math
import os
import time
import traceback
from datetime import datetime, timezone, timedelta
from binance_ws import BinanceFeed
from chainlink_ws import ChainlinkFeed
from trend import TrendTracker, HTFEmaTracker
from py_clob_client.client import ClobClient
from py_clob_client.clob_types import ApiCreds, OrderArgs, OrderType, BalanceAllowanceParams, AssetType
from config import (
    POLY_API_KEY, POLY_API_SECRET, POLY_API_PASSPHRASE,
    POLY_PRIVATE_KEY, POLY_FUNDER, CHAIN_ID, CLOB_HOST,
)
import aiohttp

# ── Config ──────────────────────────────────────────────────
GAMMA_API = "https://gamma-api.polymarket.com"

def _env_float(name, default):
    try:
        return float(os.getenv(name, str(default)))
    except Exception:
        return float(default)

def _env_int(name, default):
    try:
        return int(os.getenv(name, str(default)))
    except Exception:
        return int(default)

BET_SIZE = _env_float("BET_SIZE", 5.0)           # dollars per trade — start small
MIN_MOVE_PCT = _env_float("MIN_MOVE_PCT", 0.03)  # minimum BTC move % to consider (table handles the rest)
ENTRY_WINDOW = (
    _env_int("ENTRY_START", 60),
    _env_int("ENTRY_END", 840),
)
MIN_EDGE = _env_float("MIN_EDGE", 0.02)
MAX_ENTRY_PRICE = _env_float("MAX_ENTRY_PRICE", 0.95)

# Exit logic
EXIT_TARGET_PRICE = _env_float("EXIT_TARGET_PRICE", 0.95)  # resting GTC sell at this price
EXIT_BEFORE_END = _env_int("EXIT_BEFORE_END", 30)          # forced sell with 30s remaining
MONITOR_INTERVAL = _env_int("MONITOR_INTERVAL", 2)         # check price every 2 seconds (logging only)

# TEMA dynamic exit
EXIT_MONITOR_START = _env_int("EXIT_MONITOR_START", 600)     # seconds into interval before TEMA exit active
EXIT_CUSHION_PCT = _env_float("EXIT_CUSHION_PCT", 0.05)      # don't TEMA-exit if winning by more than this %

# Risk management
MAX_SESSION_LOSS = _env_float("MAX_SESSION_LOSS", 15.0)  # stop trading after $15 cumulative loss
MAX_SPREAD = _env_float("MAX_SPREAD", 0.06)              # skip entry if spread > 6 cents
ENTRY_ORDER_TIMEOUT = _env_float("ENTRY_ORDER_TIMEOUT", 20.0)  # seconds to wait for entry fill
EXIT_ORDER_TIMEOUT = _env_float("EXIT_ORDER_TIMEOUT", 20.0)    # seconds to wait for exit fill

DATA_DIR = "data"
TRADES_FILE = os.path.join(DATA_DIR, "live_trades.json")
LOG_FILE = os.path.join(DATA_DIR, "live_log.jsonl")
TRADES_CSV = os.path.join(DATA_DIR, "live_trades.csv")
TRADES_TXT = os.path.join(DATA_DIR, "live_log.txt")

ET = timezone(timedelta(hours=-5))
BANKROLL_START = 0  # will be read from account

# ── Calibrated Fair Value Table ──────────────────────────────
# Generated by calibrate.py from 90 days of Coinbase BTC-USD 1-min data.
# Each cell = P(momentum persists | move_size, elapsed_time).
# Source: 8,637 intervals, 110,149 observations. Generated 2026-02-16.
#
# Move buckets are absolute BTC move from interval open (%).
# Elapsed buckets are seconds since interval start.
FAIR_VALUE_TABLE = {
    "0.03-0.05": {"60-180": 0.5976, "180-420": 0.6522, "420-600": 0.6968, "600-840": 0.8003},
    "0.05-0.10": {"60-180": 0.6546, "180-420": 0.7144, "420-600": 0.7733, "600-840": 0.8714},
    "0.10-0.20": {"60-180": 0.6864, "180-420": 0.7772, "420-600": 0.8557, "600-840": 0.9433},
    "0.20+":     {"60-180": 0.7454, "180-420": 0.8672, "420-600": 0.9360, "600-840": 0.9823},
}

MOVE_BINS = [
    (0.03, 0.05, "0.03-0.05"),
    (0.05, 0.10, "0.05-0.10"),
    (0.10, 0.20, "0.10-0.20"),
    (0.20, 999.0, "0.20+"),
]

ELAPSED_BINS = [
    (60,  180, "60-180"),
    (180, 420, "180-420"),
    (420, 600, "420-600"),
    (600, 841, "600-840"),
]


def lookup_fair_value(abs_move_pct, elapsed_secs):
    """Look up calibrated win rate from the embedded table.

    Returns the fair value (float) or None if outside all buckets.
    """
    move_label = None
    for lo, hi, label in MOVE_BINS:
        if lo <= abs_move_pct < hi:
            move_label = label
            break

    elapsed_label = None
    for lo, hi, label in ELAPSED_BINS:
        if lo <= elapsed_secs < hi:
            elapsed_label = label
            break

    if move_label is None or elapsed_label is None:
        return None, None, None

    fair = FAIR_VALUE_TABLE.get(move_label, {}).get(elapsed_label)
    return fair, move_label, elapsed_label


# ── Helpers ─────────────────────────────────────────────────
def ensure_dirs():
    os.makedirs(DATA_DIR, exist_ok=True)


def fmt_et(ts):
    return datetime.fromtimestamp(ts, tz=ET).strftime("%I:%M:%S %p")


def fmt_et_short(ts):
    return datetime.fromtimestamp(ts, tz=ET).strftime("%I:%M %p")


def load_state():
    if os.path.exists(TRADES_FILE):
        with open(TRADES_FILE, "r") as f:
            state = json.load(f)
            return state.get("trades", []), state.get("bankroll", 0)
    return [], 0


def save_state(trades, bankroll):
    with open(TRADES_FILE, "w") as f:
        json.dump({"trades": trades, "bankroll": bankroll, "updated": time.time()}, f, indent=2)
    _write_csv(trades, bankroll)


def _write_csv(trades, bankroll):
    import csv
    headers = ["#", "Time (ET)", "Interval", "Side", "Strength", "Entry Price",
               "Move at Entry", "BTC Open", "BTC Close", "Final Move",
               "Result", "P&L", "Bankroll", "Order ID"]
    with open(TRADES_CSV, "w", newline="") as f:
        w = csv.writer(f)
        w.writerow(headers)
        for i, t in enumerate(trades, 1):
            w.writerow([
                i,
                fmt_et(t.get("ts", 0)),
                t.get("slug", ""),
                t.get("side", ""),
                t.get("strength", ""),
                f"{t.get('entry_price', 0):.3f}",
                f"{t.get('move_at_entry', 0):+.3f}%",
                f"${t.get('btc_open', 0):,.2f}",
                f"${t.get('btc_close', 0):,.2f}" if t.get("btc_close") else "",
                f"{t.get('final_move', 0):+.3f}%" if t.get("final_move") is not None else "",
                "WIN" if t.get("won") else "LOSS" if t.get("won") is not None else "OPEN",
                f"${t.get('pnl', 0):+.2f}" if t.get("pnl") is not None else "",
                f"${bankroll:.2f}",
                t.get("order_id", ""),
            ])


def log_event(event_type, data):
    entry = {"ts": time.time(), "type": event_type, **data}
    with open(LOG_FILE, "a") as f:
        f.write(json.dumps(entry) + "\n")
    ts_str = fmt_et(time.time())
    with open(TRADES_TXT, "a") as f:
        if event_type == "interval_start":
            f.write(f"\n[{ts_str}] === New Interval: {data.get('slug','')} | Bankroll: ${data.get('bankroll',0):.2f} ===\n")
        elif event_type == "open_price":
            f.write(f"[{ts_str}] Open: ${data.get('price',0):,.2f}\n")
        elif event_type == "entry":
            f.write(f"[{ts_str}] ENTRY: {data.get('side','')} | {data.get('move_bucket','')}% @ {data.get('elapsed_bucket','')}s | fair {data.get('fair_value',0):.3f} | @ {data.get('entry_price',0):.3f} | BTC ${data.get('btc_at_entry',0):,.2f} ({data.get('move_at_entry',0):+.3f}%) | Edge: {data.get('edge',0):+.3f} | Order: {data.get('order_id','?')}\n")
        elif event_type == "resolve":
            result = "WIN" if data.get("won") else "LOSS"
            f.write(f"[{ts_str}] {result}: P&L ${data.get('pnl',0):+.2f} | Bankroll: ${data.get('bankroll',0):.2f}\n")
        elif event_type == "order_error":
            f.write(f"[{ts_str}] ORDER ERROR: {data.get('error','')}\n")
        elif event_type == "exit":
            f.write(f"[{ts_str}] EXIT ({data.get('reason','')}): sold @ {data.get('exit_price',0):.3f} | P&L ${data.get('pnl',0):+.2f} | Bankroll: ${data.get('bankroll',0):.2f}\n")
        elif event_type in ("sell_error",):
            f.write(f"[{ts_str}] SELL ERROR: {data.get('error','')} (reason: {data.get('reason','')})\n")
        elif event_type in ("error", "fatal"):
            f.write(f"[{ts_str}] ERROR: {data.get('error','')}\n")


# ── Interval State ──────────────────────────────────────────
class IntervalState:
    def __init__(self, start_ts):
        self.start_ts = start_ts
        self.end_ts = start_ts + 900
        self.open_price = None
        self.latest_price = None
        self.high_price = None
        self.low_price = None
        self.trade_taken = False
        self.trade = None
        self.last_log_minute = -1       # throttle below-threshold signal logging (per minute)
        self.last_eval_half_min = -1    # throttle entry evaluations (per 30s)
        # Exit tracking
        self.exited = False
        self.exit_reason = None      # "target_fill", "forced_exit"
        self.exit_price = None
        self.exit_pnl = None
        self.last_monitor_ts = 0     # throttle Polymarket price checks
        self.sell_attempts = 0       # cap retries on failed sells
        self.tp_order_id = None      # resting GTC sell order for target price
        self.tema_exit_pending = False  # TEMA exit sell initiated

    @property
    def elapsed(self):
        return time.time() - self.start_ts

    @property
    def remaining(self):
        return self.end_ts - time.time()

    @property
    def move_pct(self):
        if self.open_price and self.latest_price:
            return ((self.latest_price - self.open_price) / self.open_price) * 100
        return 0.0

    @property
    def slug(self):
        return f"btc-updown-15m-{self.start_ts}"


# ── Live Trader ─────────────────────────────────────────────
class LiveTrader:
    def __init__(self, single=False, audit=False):
        ensure_dirs()
        self.trades, self.bankroll = load_state()
        self.current_interval = None
        # Price feed: Chainlink (via Polymarket RTDS) is the default because
        # it's the same oracle Polymarket uses to resolve BTC 15-min markets.
        # Set PRICE_FEED=binance to fall back to Binance if needed.
        feed_choice = os.getenv("PRICE_FEED", "chainlink").lower()
        if feed_choice == "binance":
            self.feed = BinanceFeed(symbols=["BTC"], on_trade=self._on_trade)
            self._feed_name = "Binance"
        else:
            self.feed = ChainlinkFeed(symbols=["BTC"], on_trade=self._on_trade)
            self._feed_name = "Chainlink"
        self.trend = TrendTracker()
        self.htf_ema = HTFEmaTracker()
        self.exit_tema = TrendTracker(candle_interval=60, fast_period=5, slow_period=12)
        self._http = None
        self._last_status_bucket = 0
        self._pending_resolve = None
        self._single = single        # single trade mode
        self._trade_placed = False    # have we placed our one trade?
        self._resolved = False        # has it resolved?
        self._audit = audit
        self._first_interval = True   # skip first (partial) interval — open price unreliable

        # Runtime config (can be overridden for audit mode)
        self.bet_size = BET_SIZE
        self.min_move_pct = MIN_MOVE_PCT
        self.entry_window = ENTRY_WINDOW
        self.min_edge = MIN_EDGE
        self.max_entry_price = MAX_ENTRY_PRICE
        self.exit_target_price = EXIT_TARGET_PRICE
        self.exit_before_end = EXIT_BEFORE_END
        self.monitor_interval = MONITOR_INTERVAL
        self.max_session_loss = MAX_SESSION_LOSS
        self.max_spread = MAX_SPREAD
        self.entry_order_timeout = ENTRY_ORDER_TIMEOUT
        self.exit_order_timeout = EXIT_ORDER_TIMEOUT
        self.session_pnl = 0.0          # tracks cumulative P&L this session
        self._circuit_breaker = False    # set True when max loss hit

        if self._audit:
            self._apply_audit_overrides()

        # Init CLOB client — derive fresh API creds on startup
        # (Polymarket L2 keys are IP-bound, so we re-derive each deploy)
        # signature_type=2 (POLY_GNOSIS_SAFE) for MetaMask proxy wallet accounts
        self.clob = ClobClient(
            host=CLOB_HOST,
            chain_id=CHAIN_ID,
            key=POLY_PRIVATE_KEY,
            signature_type=2,
        )
        print("Deriving API credentials...", flush=True)
        try:
            creds = self.clob.derive_api_key()

            # Handle both dict and object responses
            if isinstance(creds, dict):
                api_key = creds.get("apiKey") or creds.get("api_key")
                api_secret = creds.get("secret") or creds.get("api_secret")
                api_passphrase = creds.get("passphrase") or creds.get("api_passphrase")
            else:
                api_key = creds.api_key
                api_secret = creds.api_secret
                api_passphrase = creds.api_passphrase

            self.clob = ClobClient(
                host=CLOB_HOST,
                chain_id=CHAIN_ID,
                key=POLY_PRIVATE_KEY,
                creds=ApiCreds(api_key, api_secret, api_passphrase),
                funder=POLY_FUNDER,
                signature_type=2,
            )
            print(f"API creds derived OK (key: {api_key[:12]}...)", flush=True)

            # Quick auth check
            try:
                keys = self.clob.get_api_keys()
                print(f"Auth check: {keys}", flush=True)
            except Exception as ae:
                print(f"Auth check failed: {ae}", flush=True)

            # Refresh CLOB allowance cache for both USDC (buys) and Conditional Tokens (sells).
            # This does NOT set on-chain approvals — run set_allowances.py for that.
            # It tells the CLOB server to re-read on-chain state so it knows we have approval.
            self._refresh_allowances()
        except Exception as e:
            print(f"WARNING: Could not derive creds: {e}", flush=True)
            print("Falling back to env creds...", flush=True)
            self.clob = ClobClient(
                host=CLOB_HOST,
                chain_id=CHAIN_ID,
                key=POLY_PRIVATE_KEY,
                creds=ApiCreds(POLY_API_KEY, POLY_API_SECRET, POLY_API_PASSPHRASE),
                funder=POLY_FUNDER,
                signature_type=2,
            )

    def _refresh_allowances(self):
        """Tell the CLOB server to refresh its cached view of on-chain allowances.

        Polymarket's CLOB caches your on-chain token approvals.  After a buy,
        the conditional-token balance changes, but the server may not see it
        until we explicitly ask it to refresh.  Without this, sell orders fail
        with 'not enough balance / allowance'.

        This is a server-side cache refresh — NOT an on-chain transaction.
        On-chain approvals (setApprovalForAll) must be set once via
        set_allowances.py or the Polymarket UI.

        NOTE: Only USDC (ERC20 / COLLATERAL) is refreshed at startup.
        Conditional Tokens (ERC1155) require a valid token_id, which we
        don't have until we discover a market.  The per-sell refresh in
        _sell_position handles that with the actual token_id.
        """
        try:
            params = BalanceAllowanceParams(asset_type=AssetType.COLLATERAL)
            result = self.clob.update_balance_allowance(params)
            print(f"  Allowance refresh (USDC): {result}", flush=True)
        except Exception as e:
            print(f"  Allowance refresh (USDC) failed: {e}", flush=True)

    def _log_balance(self):
        try:
            params = BalanceAllowanceParams(asset_type=AssetType.COLLATERAL)
            bal = self.clob.get_balance_allowance(params)
            print(f"USDC balance/allowance: {bal}", flush=True)
            log_event("balance", {"balance": bal})
        except Exception as e:
            print(f"Balance check failed: {e}", flush=True)
            log_event("error", {"context": "balance", "error": str(e)})

        # NOTE: Conditional token balance/allowance requires a specific token_id
        # (ERC1155). We can't check it at startup without a market — the per-sell
        # refresh in _sell_position handles this with the actual token_id.

    def _log_and_check_funder(self):
        """Log wallet addresses and verify POLY_FUNDER is set."""
        try:
            from eth_account import Account
        except Exception as e:
            print(f"WARNING: Cannot import eth_account to verify funder address: {e}", flush=True)
            if not POLY_FUNDER:
                print("FATAL: POLY_FUNDER is missing.", flush=True)
                return False
            return True

        try:
            derived = Account.from_key(POLY_PRIVATE_KEY).address
            print(f"EOA (signer): {derived}", flush=True)
            print(f"Funder:       {POLY_FUNDER}", flush=True)
            log_event("wallet", {"derived_address": derived, "funder": POLY_FUNDER})

            if not POLY_FUNDER:
                print("FATAL: POLY_FUNDER is missing.", flush=True)
                return False

            if derived.lower() != POLY_FUNDER.lower():
                print("Funder != EOA (proxy wallet mode)", flush=True)

            return True
        except Exception as e:
            print(f"FATAL: Could not derive address from POLY_PRIVATE_KEY: {e}", flush=True)
            return False

    def _get_interval_start(self):
        now = datetime.now(timezone.utc)
        mins = (now.minute // 15) * 15
        base = now.replace(minute=mins, second=0, microsecond=0)
        return int(base.timestamp())

    def _rotate_interval(self):
        ts = self._get_interval_start()
        if self.current_interval is None or self.current_interval.start_ts != ts:
            prev = self.current_interval
            self.current_interval = IntervalState(ts)
            self._last_status_bucket = 0

            if self._first_interval:
                self._first_interval = False
                print(f"\n--- {fmt_et_short(ts)}-{fmt_et_short(ts+900)} ET | SKIPPING (partial first interval) ---", flush=True)
            else:
                td = self.trend.get_detail()
                htf_d = self.htf_ema.get_detail()
                trend_str = f" | trend={td['trend']}" if td['ready'] else ""
                htf_str = f" | HTF: EMA(5)=${htf_d['ema_value']:,.2f}" if htf_d['ready'] else ""
                print(f"\n--- {fmt_et_short(ts)}-{fmt_et_short(ts+900)} ET | ${self.bankroll:.2f} | {len(self.trades)} trades{trend_str}{htf_str} ---")
                log_event("interval_start", {"slug": self.current_interval.slug, "bankroll": self.bankroll})

            if prev and prev.trade:
                self._pending_resolve = prev

    async def _on_trade(self, symbol, price, exchange_ts, local_ts):
        try:
            await self._on_trade_inner(symbol, price, exchange_ts, local_ts)
        except Exception as e:
            log_event("error", {"context": "on_trade", "error": str(e)})
            print(f"  [ERR] {e}")

    async def _on_trade_inner(self, symbol, price, exchange_ts, local_ts):
        # Update indicators with every price tick
        self.trend.update_price(price, exchange_ts)
        self.htf_ema.update_price(price, exchange_ts)
        self.exit_tema.update_price(price, exchange_ts)

        self._rotate_interval()

        if self._pending_resolve:
            prev = self._pending_resolve
            self._pending_resolve = None
            await self._resolve(prev)

        iv = self.current_interval

        if iv.open_price is None:
            iv.open_price = price
            iv.high_price = price
            iv.low_price = price
            log_event("open_price", {"slug": iv.slug, "price": price})

        iv.latest_price = price
        if price > (iv.high_price or 0):
            iv.high_price = price
        if price < (iv.low_price or float('inf')):
            iv.low_price = price

        # Status every 60s
        bucket = int(iv.elapsed) // 60
        if bucket > self._last_status_bucket and iv.elapsed > 10:
            self._last_status_bucket = bucket
            if iv.exited and iv.trade:
                tag = f" [{iv.trade['side']}] EXITED ({iv.exit_reason})"
            elif iv.trade_taken and iv.trade:
                tag = f" [{iv.trade['side']}] OPEN"
            elif iv.trade_taken:
                tag = " [no fill]"
            else:
                tag = ""
            trend_tag = f" | trend={self.trend.get_trend()}"
            print(f"  {iv.move_pct:+.3f}% | ${price:,.0f} | {iv.remaining:.0f}s left{tag}{trend_tag}")

        # Monitor open position for TP/SL/forced exit
        if iv.trade_taken and iv.trade and not iv.exited:
            await self._monitor_position(iv)

        # Circuit breaker — stop trading if max session loss exceeded
        if self._circuit_breaker:
            return

        # Signal logic — skip if first interval, already traded, or outside entry window
        if self._first_interval:
            return
        if iv.trade_taken or iv.elapsed < self.entry_window[0] or iv.elapsed > self.entry_window[1]:
            return
        if self._single and self._trade_placed:
            return

        abs_move = abs(iv.move_pct)

        # Below minimum move — not worth evaluating
        if abs_move < self.min_move_pct:
            if abs_move > 0.02:
                minute = int(iv.elapsed) // 60
                if minute != iv.last_log_minute:
                    iv.last_log_minute = minute
                    print(f"  [SIGNAL] {abs_move:.3f}% @ {iv.elapsed:.0f}s — below threshold", flush=True)
            return

        # Look up calibrated fair value from the table
        fair_value, move_bucket, elapsed_bucket = lookup_fair_value(abs_move, iv.elapsed)
        if fair_value is None:
            return

        # Throttle evaluations to once per 30 seconds (balance API load vs responsiveness)
        half_min = int(iv.elapsed) // 30
        if half_min == iv.last_eval_half_min:
            return
        iv.last_eval_half_min = half_min

        signal = "Up" if iv.move_pct > 0 else "Down"

        # HTF EMA(5) on 15m candles — entry filter
        htf_aligned = self.htf_ema.is_aligned(signal)
        if htf_aligned is False:
            minute = int(iv.elapsed) // 60
            if minute != iv.last_log_minute:
                iv.last_log_minute = minute
                htf_d = self.htf_ema.get_detail()
                print(f"  [FILTERED] {signal} {abs_move:.4f}% @ {iv.elapsed:.0f}s -- "
                      f"HTF EMA(5)=${htf_d['ema_value']:,.2f} vs ${htf_d['price']:,.2f} misaligned",
                      flush=True)
            return

        await self._evaluate(iv, signal, fair_value, move_bucket, elapsed_bucket, price)

    async def _evaluate(self, iv, signal, fair_value, move_bucket, elapsed_bucket, btc_price):
        try:
            if self._http is None or self._http.closed:
                self._http = aiohttp.ClientSession()

            market = await self._fetch_market(iv.slug)
            if not market:
                return

            prices = json.loads(market.get("outcomePrices", "[]"))
            clob_ids = json.loads(market.get("clobTokenIds", "[]"))
            outcomes = json.loads(market.get("outcomes", "[]"))
            if len(prices) < 2 or len(clob_ids) < 2 or len(outcomes) < 2:
                return

            # Map outcomes to indices — never assume ordering
            outcome_map = {}  # {"Up": 0, "Down": 1} or reversed
            for i, name in enumerate(outcomes):
                outcome_map[name] = i

            if signal not in outcome_map:
                print(f"  [SKIP] Signal '{signal}' not in outcomes {outcomes}", flush=True)
                return

            sig_idx = outcome_map[signal]
            price_up = float(prices[outcome_map.get("Up", 0)])
            price_down = float(prices[outcome_map.get("Down", 1)])
            token_id = clob_ids[sig_idx]
            accepting = market.get("acceptingOrders")
            min_size = market.get("orderMinSize")

            if accepting is False:
                log_event("signal_skip", {
                    "slug": iv.slug, "signal": signal, "move_bucket": move_bucket,
                    "reason": "acceptingOrders=false",
                })
                return

            # Fetch live orderbook from CLOB (not stale Gamma prices)
            best_bid, best_ask, bid_depth, ask_depth, spread = await self._get_order_book(token_id)
            if best_ask is None or best_bid is None:
                print(f"  [SKIP] No orderbook data for {signal}", flush=True)
                return

            # Actual buy price: we place a GTC limit at best_ask + 0.01 to fill aggressively.
            # Edge must be calculated against THIS price, not bare best_ask.
            buy_price = round(min(best_ask + 0.01, 0.99), 2)
            our_price = buy_price

            # Spread filter — skip if spread is too wide (eating our edge)
            if spread > self.max_spread:
                print(f"  [SKIP] Spread {spread:.3f} > max {self.max_spread:.3f} | bid {best_bid:.3f} / ask {best_ask:.3f}", flush=True)
                log_event("signal_skip", {
                    "slug": iv.slug, "signal": signal, "move_bucket": move_bucket,
                    "spread": spread, "best_bid": best_bid, "best_ask": best_ask,
                    "reason": "spread_too_wide",
                })
                return

            # Fair value is already calibrated from the table — no static guessing
            fair = fair_value
            edge = round(fair - our_price, 4)

            log_event("market_snapshot", {
                "slug": iv.slug,
                "signal": signal,
                "move_bucket": move_bucket,
                "elapsed_bucket": elapsed_bucket,
                "fair_value": fair,
                "best_bid": best_bid,
                "best_ask": best_ask,
                "spread": spread,
                "bid_depth": round(bid_depth, 2),
                "ask_depth": round(ask_depth, 2),
                "our_price": our_price,
                "edge": edge,
                "accepting_orders": accepting,
                "order_min_size": min_size,
            })

            if our_price > self.max_entry_price or edge < self.min_edge:
                print(f"  [SKIP] fair {fair:.3f} - ask {our_price:.3f} = edge {edge:+.3f} (need {self.min_edge}) | {move_bucket}% @ {elapsed_bucket}s", flush=True)
                log_event("signal_skip", {
                    "slug": iv.slug, "signal": signal, "move_bucket": move_bucket,
                    "our_price": our_price, "edge": edge, "fair_value": fair,
                    "move": iv.move_pct,
                })
                return

            print(f"  [BOOK] token={token_id[:16]}... bid {best_bid:.3f} / ask {best_ask:.3f} | spread {spread:.3f} | depth ${bid_depth:.0f}/${ask_depth:.0f}", flush=True)
            order_id = await self._place_order(token_id, buy_price, self.bet_size)

            if not order_id:
                log_event("order_error_retry", {"token_id": token_id, "reason": "no_order_id"})
                return

            # Order was accepted — now we're committed. Mark trade_taken to
            # prevent duplicate orders while we wait for fill confirmation.
            iv.trade_taken = True

            # Confirm fill — poll order status (don't assume filled just because we got an orderID)
            filled_size, fill_price = await self._confirm_fill(order_id, max_wait=self.entry_order_timeout)
            if filled_size <= 0:
                print(f"  [SKIP] Order {order_id[:16]}... not filled — no position", flush=True)
                log_event("order_unfilled", {"order_id": order_id, "token_id": token_id})
                return

            # Use actual fill data for position tracking
            actual_cost = round(filled_size * fill_price, 4)

            entry_trend = self.trend.get_detail()
            htf_d = self.htf_ema.get_detail()
            exit_tema_trend = self.exit_tema.get_trend()

            iv.trade = {
                "side": signal,
                "entry_price": fill_price,
                "market_price_at_entry": our_price,
                "limit_price": buy_price,
                "shares": filled_size,
                "entry_shares": filled_size,
                "open_shares": filled_size,
                "cost": actual_cost,
                "btc_at_entry": btc_price,
                "btc_open": iv.open_price,
                "move_at_entry": iv.move_pct,
                "strength": move_bucket,
                "fair_value": fair,
                "move_bucket": move_bucket,
                "elapsed_bucket": elapsed_bucket,
                "elapsed": iv.elapsed,
                "slug": iv.slug,
                "market_up": price_up,
                "market_down": price_down,
                "edge": edge,
                "token_id": token_id,
                "order_id": order_id,
                "ts": time.time(),
                "trend": entry_trend["trend"],
                "tema_fast": entry_trend["tema_fast"],
                "tema_slow": entry_trend["tema_slow"],
                "htf_ema": htf_d.get("ema_value"),
                "prev_exit_tema": exit_tema_trend if exit_tema_trend != "Neutral" else None,
                "realized_proceeds": 0.0,
                "realized_pnl": 0.0,
                "tp_size_matched": 0.0,
            }
            self.bankroll -= actual_cost
            save_state(self.trades, self.bankroll)

            self._trade_placed = True
            print(f"  >> FILLED {signal} | {move_bucket}% @ {elapsed_bucket}s | fair {fair:.3f} | {filled_size} shares @ {fill_price:.3f} (limit {buy_price:.2f}) | edge {edge:+.3f} | cost ${actual_cost:.2f} | order {order_id[:16]}...", flush=True)
            log_event("entry", {**iv.trade})
            # Target sell will be placed by _monitor_position after settlement delay

        except Exception as e:
            log_event("error", {"context": "evaluate", "error": str(e)})
            print(f"  [ERR evaluate] {e}")

    async def _place_order(self, token_id, price, amount):
        """Place a GTC limit buy order. Returns order_id or None."""
        try:
            # GTC requires USDC cost (size * price) to have max 2 decimal places.
            price_cents = int(round(price * 100))
            raw_size_cents = int(amount * 100 * 100 // price_cents)

            size_cents = raw_size_cents
            while size_cents > 100 and (size_cents * price_cents) % 100 != 0:
                size_cents -= 1

            size = size_cents / 100.0
            if size * price < 1.0:
                size = round(1.05 / price, 2)

            order_args = OrderArgs(
                token_id=token_id,
                price=price,
                size=size,
                side="BUY",
            )
            print(f"  [ORDER] GTC BUY token={token_id[:16]}... price={price} size={size} (~${size * price:.2f})", flush=True)

            # Two-step: create standard order, then post with GTC.
            loop = asyncio.get_event_loop()
            signed_order = await loop.run_in_executor(
                None, lambda: self.clob.create_order(order_args)
            )
            result = await loop.run_in_executor(
                None, lambda: self.clob.post_order(signed_order, OrderType.GTC)
            )

            if not result:
                print(f"  [ORDER] Empty response", flush=True)
                return None

            # Parse response
            error_msg = ""
            order_id = None
            status = ""
            if isinstance(result, dict):
                error_msg = result.get("errorMsg", "")
                order_id = result.get("orderID", "")
                status = result.get("status", "")
            else:
                order_id = str(result)

            if error_msg:
                print(f"  [ORDER] GTC rejected: {error_msg}", flush=True)
                log_event("order_error", {"error": error_msg, "token_id": token_id})
                return None

            if not order_id:
                print(f"  [ORDER] No order ID: {result}", flush=True)
                return None

            print(f"  [ORDER] GTC accepted: status={status} id={order_id[:16]}...", flush=True)
            return order_id

        except Exception as e:
            log_event("order_error", {"error": str(e), "token_id": token_id})
            print(f"  [ORDER ERROR] {e}")
            return None

    async def _confirm_fill(self, order_id, max_wait=20.0):
        """Poll fill details for an order.

        Returns:
            (filled_size, avg_price)
        where filled_size can be partial if the order times out/cancels.
        """
        loop = asyncio.get_event_loop()
        start = time.time()
        attempts = 0
        last_matched = 0.0
        last_price = 0.0

        while time.time() - start < max_wait:
            attempts += 1
            try:
                order = await loop.run_in_executor(None, lambda: self.clob.get_order(order_id))

                if not order:
                    print(f"  [FILL] No order data for {order_id[:16]}... (attempt {attempts})", flush=True)
                    await asyncio.sleep(1.0)
                    continue

                # Parse order fields — handle both dict and object responses.
                if isinstance(order, dict):
                    size_matched = float(order.get("size_matched", 0))
                    original_size = float(order.get("original_size", 0))
                    status = order.get("status", "unknown")
                    raw_avg = order.get("average_matched_price")
                    raw_match = order.get("matched_price")
                    raw_limit = order.get("price", 0)
                else:
                    size_matched = float(getattr(order, "size_matched", 0))
                    original_size = float(getattr(order, "original_size", 0))
                    status = getattr(order, "status", "unknown")
                    raw_avg = getattr(order, "average_matched_price", None)
                    raw_match = getattr(order, "matched_price", None)
                    raw_limit = getattr(order, "price", 0)

                avg_price = float(raw_avg) if raw_avg is not None and str(raw_avg).strip() not in ("", "0") else 0.0
                match_price = float(raw_match) if raw_match is not None and str(raw_match).strip() not in ("", "0") else 0.0
                limit_price = float(raw_limit) if raw_limit else 0.0
                price = avg_price if avg_price > 0 else (match_price if match_price > 0 else limit_price)

                print(f"  [FILL] status={status} filled={size_matched}/{original_size} | avg={raw_avg} match={raw_match} limit={raw_limit} -> price={price}", flush=True)

                if size_matched > last_matched:
                    last_matched = size_matched
                    if price > 0:
                        last_price = price

                # Do not treat any partial match as complete; wait for full size.
                if original_size > 0 and size_matched >= original_size:
                    if avg_price == 0 and match_price == 0 and attempts < 3:
                        print("  [FILL] Full size matched but avg price pending — re-polling...", flush=True)
                        await asyncio.sleep(1.0)
                        continue
                    return size_matched, (price if price > 0 else last_price)

                if status in ("CANCELED", "CANCELLED", "EXPIRED"):
                    if last_matched > 0:
                        return last_matched, last_price
                    return 0, 0

            except Exception as e:
                print(f"  [FILL] Check error: {e}", flush=True)
            await asyncio.sleep(1.0)

        # Timed out waiting; cancel to avoid resting stale orders.
        try:
            await loop.run_in_executor(None, lambda: self.clob.cancel(order_id))
            print(f"  [FILL] Timeout after {max_wait:.0f}s — canceled {order_id[:16]}...", flush=True)
        except Exception as e:
            print(f"  [FILL] Timeout cancel failed: {e}", flush=True)

        # Best-effort fetch of final matched quantity after cancel.
        try:
            order = await loop.run_in_executor(None, lambda: self.clob.get_order(order_id))
            if order:
                if isinstance(order, dict):
                    size_matched = float(order.get("size_matched", 0))
                    raw_avg = order.get("average_matched_price")
                    raw_match = order.get("matched_price")
                    raw_limit = order.get("price", 0)
                else:
                    size_matched = float(getattr(order, "size_matched", 0))
                    raw_avg = getattr(order, "average_matched_price", None)
                    raw_match = getattr(order, "matched_price", None)
                    raw_limit = getattr(order, "price", 0)
                avg_price = float(raw_avg) if raw_avg is not None and str(raw_avg).strip() not in ("", "0") else 0.0
                match_price = float(raw_match) if raw_match is not None and str(raw_match).strip() not in ("", "0") else 0.0
                limit_price = float(raw_limit) if raw_limit else 0.0
                final_price = avg_price if avg_price > 0 else (match_price if match_price > 0 else limit_price)
                if size_matched > last_matched:
                    last_matched = size_matched
                if final_price > 0:
                    last_price = final_price
        except Exception:
            pass

        return last_matched, last_price

    def _apply_target_match_delta(self, iv, matched_size, raw_avg):
        """Book newly matched size from the resting target sell order."""
        trade = iv.trade
        prev_matched = float(trade.get("tp_size_matched", 0.0))
        new_matched = max(float(matched_size) - prev_matched, 0.0)
        if new_matched <= 0:
            return

        open_shares = float(trade.get("open_shares", trade.get("shares", 0.0)))
        delta = min(new_matched, open_shares)
        if delta <= 0:
            return

        exit_price = float(raw_avg) if raw_avg and str(raw_avg).strip() not in ("", "0") else self.exit_target_price
        proceeds = exit_price * delta
        pnl_delta = (exit_price - trade["entry_price"]) * delta

        trade["tp_size_matched"] = prev_matched + delta
        trade["open_shares"] = max(open_shares - delta, 0.0)
        trade["realized_proceeds"] = float(trade.get("realized_proceeds", 0.0)) + proceeds
        trade["realized_pnl"] = float(trade.get("realized_pnl", 0.0)) + pnl_delta

        self.bankroll += round(proceeds, 2)
        save_state(self.trades, self.bankroll)

        print(
            f"  [TARGET] Matched +{delta:.2f} @ {exit_price:.3f} | "
            f"remaining {trade['open_shares']:.2f} shares",
            flush=True,
        )

    async def _get_order_book(self, token_id):
        """Get full orderbook from CLOB. Returns (best_bid, best_ask, bid_depth, ask_depth, spread) or Nones."""
        loop = asyncio.get_event_loop()
        try:
            book = await loop.run_in_executor(
                None, lambda: self.clob.get_order_book(token_id)
            )

            if not book:
                return None, None, None, None, None

            # Parse bids and asks — handle both dict and object
            if isinstance(book, dict):
                bids = book.get("bids", [])
                asks = book.get("asks", [])
            else:
                bids = getattr(book, "bids", []) or []
                asks = getattr(book, "asks", []) or []

            # Best bid = highest bid, best ask = lowest ask
            best_bid = 0
            bid_depth = 0
            for b in bids:
                p = float(b.get("price", 0) if isinstance(b, dict) else getattr(b, "price", 0))
                s = float(b.get("size", 0) if isinstance(b, dict) else getattr(b, "size", 0))
                if p > best_bid:
                    best_bid = p
                bid_depth += p * s  # dollar depth

            best_ask = 1.0
            ask_depth = 0
            for a in asks:
                p = float(a.get("price", 0) if isinstance(a, dict) else getattr(a, "price", 0))
                s = float(a.get("size", 0) if isinstance(a, dict) else getattr(a, "size", 0))
                if p < best_ask:
                    best_ask = p
                ask_depth += p * s

            spread = round(best_ask - best_bid, 4) if best_ask > best_bid else 0

            return best_bid, best_ask, bid_depth, ask_depth, spread

        except Exception as e:
            print(f"  [BOOK ERR] {e}", flush=True)
            return None, None, None, None, None

    async def _get_clob_midpoint(self, token_id):
        """Get live midpoint price from CLOB orderbook (not cached Gamma API)."""
        loop = asyncio.get_event_loop()
        mid = await loop.run_in_executor(
            None, lambda: self.clob.get_midpoint(token_id)
        )
        # Returns string like "0.55" or a dict — handle both
        if isinstance(mid, dict):
            return float(mid.get("mid", 0))
        return float(mid)

    async def _get_clob_price(self, token_id, side="SELL"):
        """Get live bid/ask price from CLOB orderbook."""
        loop = asyncio.get_event_loop()
        price = await loop.run_in_executor(
            None, lambda: self.clob.get_price(token_id, side)
        )
        if isinstance(price, dict):
            return float(price.get("price", 0))
        return float(price)

    async def _try_place_target_sell(self, iv):
        """Try once to place a resting GTC sell at the target price.
        Non-blocking — called from _monitor_position on each cycle.
        Returns True if placed successfully, False otherwise."""
        trade = iv.trade
        token_id = trade["token_id"]
        shares = math.floor(float(trade.get("open_shares", trade["shares"])) * 100) / 100
        target_price = self.exit_target_price

        order_value = shares * target_price
        if order_value < 1.0:
            print(f"  [TARGET] Order value ${order_value:.2f} < $1 min — cannot place target sell", flush=True)
            return False

        # Refresh allowance so the CLOB knows we have the tokens
        try:
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(
                None, lambda: self.clob.update_balance_allowance(
                    BalanceAllowanceParams(asset_type=AssetType.CONDITIONAL, token_id=token_id)
                )
            )
        except Exception as e:
            print(f"  [TARGET] Allowance refresh failed: {e}", flush=True)

        try:
            order_args = OrderArgs(
                token_id=token_id,
                price=target_price,
                size=shares,
                side="SELL",
            )

            loop = asyncio.get_event_loop()
            signed_order = await loop.run_in_executor(
                None, lambda: self.clob.create_order(order_args)
            )
            result = await loop.run_in_executor(
                None, lambda: self.clob.post_order(signed_order, OrderType.GTC)
            )

            error_msg = ""
            order_id = None
            if isinstance(result, dict):
                error_msg = result.get("errorMsg", "")
                order_id = result.get("orderID", "")
            else:
                order_id = str(result) if result else None

            if error_msg:
                if "not enough balance" in str(error_msg).lower():
                    secs = time.time() - trade["ts"]
                    print(f"  [TARGET] Settlement pending ({secs:.0f}s since fill) — will retry", flush=True)
                else:
                    print(f"  [TARGET] GTC SELL rejected: {error_msg}", flush=True)
                return False

            if order_id:
                iv.tp_order_id = order_id
                trade["tp_order_id"] = order_id
                secs = time.time() - trade["ts"]
                print(f"  [TARGET] Resting sell placed: {order_id[:16]}... @ {target_price} ({secs:.0f}s after fill)", flush=True)
                log_event("target_sell_placed", {
                    "order_id": order_id, "target_price": target_price,
                    "shares": shares, "token_id": token_id,
                })
                return True

            return False

        except Exception as e:
            if "not enough balance" in str(e).lower():
                secs = time.time() - trade["ts"]
                print(f"  [TARGET] Settlement pending ({secs:.0f}s since fill) — will retry", flush=True)
            else:
                print(f"  [TARGET] Failed: {e}", flush=True)
            return False

    async def _monitor_position(self, iv):
        """Monitor position: TEMA exit, target sell, force exit at time limit."""
        now = time.time()
        trade = iv.trade

        # ── TEMA dynamic exit (checked every tick, not throttled) ──
        if not iv.tema_exit_pending and iv.elapsed >= EXIT_MONITOR_START:
            exit_trend = self.exit_tema.get_trend()
            entry_dir = trade["side"]
            prev_tema = trade.get("prev_exit_tema")
            skipped_cushion = False

            if (prev_tema is not None
                    and exit_trend != "Neutral"
                    and exit_trend != prev_tema):
                is_against = ((entry_dir == "Up" and exit_trend == "Down") or
                              (entry_dir == "Down" and exit_trend == "Up"))
                if is_against:
                    vs_open = iv.move_pct
                    cushion = abs(vs_open) if (
                        (entry_dir == "Up" and vs_open > 0) or
                        (entry_dir == "Down" and vs_open < 0)
                    ) else 0.0

                    if cushion > EXIT_CUSHION_PCT:
                        skipped_cushion = True
                        print(f"  [EXIT SKIP] TEMA {exit_trend} cross but cushion "
                              f"{cushion:.4f}% > {EXIT_CUSHION_PCT}% -- holding (cross stays pending)",
                              flush=True)
                    else:
                        iv.tema_exit_pending = True
                        ed = self.exit_tema.get_detail()
                        status = "ahead" if (
                            (entry_dir == "Up" and iv.latest_price >= iv.open_price) or
                            (entry_dir == "Down" and iv.latest_price < iv.open_price)
                        ) else "behind"
                        print(f"\n  >> TEMA EXIT | 1m TEMA: {exit_trend} cross | "
                              f"BTC ${iv.latest_price:,.2f} ({vs_open:+.4f}% vs open) | {status} | "
                              f"TEMA(5)=${ed['tema_fast']:,.2f} TEMA(12)=${ed['tema_slow']:,.2f}",
                              flush=True)
                        log_event("tema_exit_signal", {
                            "slug": iv.slug, "side": entry_dir,
                            "exit_trend": exit_trend, "vs_open": vs_open,
                            "cushion": cushion, "status": status,
                        })

                        # Cancel resting target sell before selling
                        if iv.tp_order_id:
                            tp_id = iv.tp_order_id
                            try:
                                loop = asyncio.get_event_loop()
                                await loop.run_in_executor(None, lambda: self.clob.cancel(tp_id))
                                print(f"  [TEMA] Cancelled resting sell {tp_id[:16]}...", flush=True)
                                order = await loop.run_in_executor(None, lambda: self.clob.get_order(tp_id))
                                if order:
                                    if isinstance(order, dict):
                                        sm = float(order.get("size_matched", 0))
                                        ra = order.get("average_matched_price")
                                    else:
                                        sm = float(getattr(order, "size_matched", 0))
                                        ra = getattr(order, "average_matched_price", None)
                                    self._apply_target_match_delta(iv, sm, ra)
                            except Exception as e:
                                print(f"  [TEMA] Cancel resting sell failed: {e}", flush=True)
                            iv.tp_order_id = None

                        if float(trade.get("open_shares", trade.get("shares", 0.0))) > 0:
                            await self._sell_position(iv, reason="tema_exit")
                        else:
                            iv.exited = True
                            iv.exit_reason = "tema_exit"
                            iv.exit_pnl = round(float(trade.get("realized_pnl", 0.0)), 2)
                        return

            if exit_trend != "Neutral" and not skipped_cushion:
                trade["prev_exit_tema"] = exit_trend

        # Forced exit — sell no matter what with EXIT_BEFORE_END seconds remaining
        if iv.remaining <= self.exit_before_end:
            print(f"  [EXIT] Forced exit — {iv.remaining:.0f}s left", flush=True)

            # Cancel resting target sell first to avoid double sell
            if iv.tp_order_id:
                tp_order_id = iv.tp_order_id
                try:
                    loop = asyncio.get_event_loop()
                    await loop.run_in_executor(None, lambda: self.clob.cancel(tp_order_id))
                    print(f"  [EXIT] Cancelled resting sell {tp_order_id[:16]}...", flush=True)

                    # Capture any fills that happened before cancellation settled.
                    order = await loop.run_in_executor(None, lambda: self.clob.get_order(tp_order_id))
                    if order:
                        if isinstance(order, dict):
                            size_matched = float(order.get("size_matched", 0))
                            raw_avg = order.get("average_matched_price")
                        else:
                            size_matched = float(getattr(order, "size_matched", 0))
                            raw_avg = getattr(order, "average_matched_price", None)
                        self._apply_target_match_delta(iv, size_matched, raw_avg)
                except Exception as e:
                    print(f"  [EXIT] Cancel resting sell failed: {e}", flush=True)
                iv.tp_order_id = None

            if float(iv.trade.get("open_shares", iv.trade.get("shares", 0.0))) <= 0:
                iv.exited = True
                iv.exit_reason = "target_fill"
                iv.exit_pnl = round(float(iv.trade.get("realized_pnl", 0.0)), 2)
                return

            await self._sell_position(iv, reason="forced_exit")
            return

        # Throttle monitoring checks
        if now - iv.last_monitor_ts < self.monitor_interval:
            return
        iv.last_monitor_ts = now

        try:
            token_id = iv.trade["token_id"]
            entry_price = iv.trade["entry_price"]

            # Try to place target sell if not yet placed (waits 5s after fill for settlement)
            if not iv.tp_order_id and (now - iv.trade["ts"]) >= 5:
                await self._try_place_target_sell(iv)

            # Check if resting target sell has filled
            if iv.tp_order_id:
                loop = asyncio.get_event_loop()
                order = await loop.run_in_executor(
                    None, lambda: self.clob.get_order(iv.tp_order_id)
                )
                if order:
                    if isinstance(order, dict):
                        status = order.get("status", "")
                        size_matched = float(order.get("size_matched", 0))
                        raw_avg = order.get("average_matched_price")
                    else:
                        status = getattr(order, "status", "")
                        size_matched = float(getattr(order, "size_matched", 0))
                        raw_avg = getattr(order, "average_matched_price", None)

                    if size_matched > 0:
                        self._apply_target_match_delta(iv, size_matched, raw_avg)

                    # Consider target exit complete only once all open shares are gone.
                    if float(iv.trade.get("open_shares", iv.trade.get("shares", 0.0))) <= 0:
                        iv.exited = True
                        iv.exit_reason = "target_fill"
                        iv.exit_price = self.exit_target_price
                        iv.exit_pnl = round(float(iv.trade.get("realized_pnl", 0.0)), 2)
                        iv.tp_order_id = None

                        iv.trade["exit_price"] = self.exit_target_price
                        iv.trade["exit_reason"] = "target_fill"
                        iv.trade["exit_order_id"] = iv.trade.get("tp_order_id", "")
                        iv.trade["exit_ts"] = time.time()
                        iv.trade["exit_pnl"] = iv.exit_pnl
                        save_state(self.trades, self.bankroll)

                        print(f"  >> TARGET FILLED | P&L ${iv.exit_pnl:+.2f} | {iv.remaining:.0f}s left", flush=True)
                        log_event("exit", {
                            "slug": iv.slug, "reason": "target_fill",
                            "entry_price": entry_price, "exit_price": self.exit_target_price,
                            "pnl": iv.exit_pnl, "bankroll": self.bankroll,
                        })
                        return

                    if status in ("CANCELED", "CANCELLED", "EXPIRED"):
                        print(f"  [MON] Target sell {status} — no longer resting", flush=True)
                        iv.tp_order_id = None

            # Informational logging — fetch midpoint for visibility
            current_price = await self._get_clob_midpoint(token_id)
            if current_price and current_price > 0:
                position_pnl_pct = (current_price - entry_price) / entry_price
                resting = f" | target @ {self.exit_target_price}" if iv.tp_order_id else " | NO resting sell"
                print(f"  [MON] {iv.trade['side']} | entry {entry_price:.3f} -> {current_price:.3f} | P&L {position_pnl_pct:+.1%} | {iv.remaining:.0f}s left{resting}", flush=True)

        except Exception as e:
            log_event("error", {"context": "monitor_position", "error": str(e)})
            print(f"  [ERR monitor] {e}", flush=True)

    async def _sell_position(self, iv, reason="manual", sell_price=None):
        """Sell the current position using an aggressive GTC limit order on the CLOB."""
        MAX_SELL_ATTEMPTS = 3
        iv.sell_attempts += 1
        if iv.sell_attempts > MAX_SELL_ATTEMPTS:
            print(f"  [SELL GAVE UP] {iv.sell_attempts - 1} failed attempts — marking exited", flush=True)
            iv.exited = True
            iv.exit_reason = f"{reason}_failed"
            iv.exit_pnl = 0  # unknown, couldn't sell
            log_event("sell_error", {"reason": reason, "error": f"gave up after {MAX_SELL_ATTEMPTS} attempts"})
            return

        trade = iv.trade
        token_id = trade["token_id"]
        open_shares = float(trade.get("open_shares", trade.get("shares", 0.0)))
        shares = math.floor(open_shares * 100) / 100  # truncate to 2 decimals — never round up

        # Refresh CLOB's view of our conditional token balance/allowance before selling.
        # Without this, the CLOB may reject the sell with "not enough balance / allowance"
        # because its cache doesn't reflect tokens received from a recent buy.
        try:
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(
                None, lambda: self.clob.update_balance_allowance(
                    BalanceAllowanceParams(asset_type=AssetType.CONDITIONAL, token_id=token_id)
                )
            )
        except Exception as e:
            print(f"  [SELL] Allowance refresh failed (continuing): {e}", flush=True)

        # Get current bid price for PnL estimation and floor price
        if sell_price is None:
            try:
                sell_price = await self._get_clob_price(token_id, side="SELL")
                if sell_price and sell_price > 0:
                    print(f"  [SELL] CLOB bid price: {sell_price:.3f}", flush=True)
                else:
                    sell_price = None
            except Exception as e:
                print(f"  [SELL] CLOB price fetch failed: {e}", flush=True)
                sell_price = None

        if sell_price is None:
            # Last resort: sell at a discount to guarantee fill
            sell_price = max(trade["entry_price"] * 0.5, 0.01)
            print(f"  [WARN] Could not fetch sell price, using {sell_price:.3f}", flush=True)

        # Floor price for sell — worst price we'll accept
        floor_price = round(max(sell_price - 0.02, 0.01), 2)

        # Check if sell meets $1 minimum — NEVER inflate shares beyond what we own
        order_value = shares * floor_price
        if order_value < 1.0:
            print(f"  [SELL SKIP] Order value ${order_value:.2f} < $1 min (have {shares} shares @ {floor_price}) — cannot sell", flush=True)
            log_event("sell_error", {"reason": reason, "error": f"below $1 min: {shares} shares @ {floor_price}"})
            # On forced exit, mark as exited anyway to avoid infinite retries
            if reason == "forced_exit":
                iv.exited = True
                iv.exit_reason = "forced_exit_below_min"
                iv.exit_pnl = 0
            return

        try:
            # Aggressive GTC limit sell. If not filled by timeout, cancel and retry.
            order_args = OrderArgs(
                token_id=token_id,
                price=floor_price,
                size=shares,
                side="SELL",
            )
            print(f"  [SELL] GTC token={token_id[:16]}... price={floor_price} size={shares} reason={reason}", flush=True)

            loop = asyncio.get_event_loop()
            signed_order = await loop.run_in_executor(
                None, lambda: self.clob.create_order(order_args)
            )
            result = await loop.run_in_executor(
                None, lambda: self.clob.post_order(signed_order, OrderType.GTC)
            )

            # Parse response
            error_msg = ""
            order_id = None
            if isinstance(result, dict):
                error_msg = result.get("errorMsg", "")
                order_id = result.get("orderID", "")
            else:
                order_id = str(result) if result else None

            if error_msg:
                print(f"  [SELL GTC REJECTED] {error_msg}", flush=True)
                log_event("sell_error", {"error": error_msg, "reason": reason})
                return

            if order_id:
                # Confirm fill details; timeout cancels stale order automatically.
                filled_size, fill_price = await self._confirm_fill(order_id, max_wait=self.exit_order_timeout)
                if filled_size <= 0:
                    print(f"  [SELL UNFILLED] {order_id[:16]}... after {self.exit_order_timeout:.0f}s", flush=True)
                    log_event("sell_error", {"reason": reason, "error": "unfilled_timeout", "order_id": order_id})
                    return
                exit_price = fill_price if fill_price > 0 else sell_price

                # Use actual filled_size for P&L — not trade["shares"] — in case of partial fill
                sold_shares = min(filled_size, open_shares)
                pnl_est = (exit_price - trade["entry_price"]) * sold_shares
                remaining = max(open_shares - sold_shares, 0.0)
                trade["open_shares"] = remaining
                trade["realized_proceeds"] = float(trade.get("realized_proceeds", 0.0)) + (exit_price * sold_shares)
                trade["realized_pnl"] = float(trade.get("realized_pnl", 0.0)) + pnl_est

                # Credit the sale proceeds back (only for shares actually sold)
                proceeds = exit_price * sold_shares
                self.bankroll += round(proceeds, 2)

                if remaining <= 0:
                    iv.exited = True
                    iv.exit_reason = reason
                    iv.exit_price = exit_price
                    iv.exit_pnl = round(float(trade.get("realized_pnl", 0.0)), 2)
                    trade["exit_price"] = exit_price
                    trade["exit_reason"] = reason
                    trade["exit_order_id"] = order_id
                    trade["exit_ts"] = time.time()
                    trade["exit_pnl"] = iv.exit_pnl

                save_state(self.trades, self.bankroll)

                print(
                    f"  >> SOLD ({reason}) @ {exit_price:.3f} | P&L ${pnl_est:+.2f} | "
                    f"remaining {remaining:.2f} | order {order_id[:16]}...",
                    flush=True,
                )
                log_event("exit", {
                    "slug": iv.slug, "reason": reason,
                    "entry_price": trade["entry_price"],
                    "exit_price": exit_price,
                    "pnl": round(float(trade.get("realized_pnl", 0.0)), 2),
                    "bankroll": self.bankroll,
                    "order_id": order_id,
                })
            else:
                print(f"  [SELL FAILED] No order ID returned for {reason}", flush=True)
                log_event("sell_error", {"reason": reason, "error": "no order_id"})

        except Exception as e:
            log_event("sell_error", {"error": str(e), "reason": reason})
            print(f"  [SELL ERROR] {e}", flush=True)

    async def _resolve(self, iv):
        """Resolve a completed interval's trade.

        Two paths:
        1. Early exit (target_fill/forced) — position already sold, just log final outcome.
        2. Hold to resolution — original behavior, settle based on BTC close.
        """
        if not iv.trade:
            return
        trade = iv.trade

        # Cancel any resting target sell that didn't fill
        if iv.tp_order_id:
            tp_order_id = iv.tp_order_id
            try:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(None, lambda: self.clob.cancel(tp_order_id))
                print(f"  [RESOLVE] Cancelled unfilled target sell {tp_order_id[:16]}...", flush=True)

                # Book any matched target shares before final resolution accounting.
                order = await loop.run_in_executor(None, lambda: self.clob.get_order(tp_order_id))
                if order:
                    if isinstance(order, dict):
                        size_matched = float(order.get("size_matched", 0))
                        raw_avg = order.get("average_matched_price")
                    else:
                        size_matched = float(getattr(order, "size_matched", 0))
                        raw_avg = getattr(order, "average_matched_price", None)
                    self._apply_target_match_delta(iv, size_matched, raw_avg)
            except Exception as e:
                print(f"  [RESOLVE] Cancel target sell failed: {e}", flush=True)
            iv.tp_order_id = None

        try:
            went_up = iv.latest_price >= iv.open_price
            winner = "Up" if went_up else "Down"
            trade["winner"] = winner
            trade["btc_close"] = iv.latest_price
            trade["btc_high"] = iv.high_price
            trade["btc_low"] = iv.low_price
            trade["final_move"] = ((iv.latest_price - iv.open_price) / iv.open_price) * 100

            if iv.exited:
                # Already sold — use the P&L from the sell
                pnl = iv.exit_pnl if iv.exit_pnl is not None else round(float(trade.get("realized_pnl", 0.0)), 2)
                won = pnl > 0
                trade["won"] = won
                trade["pnl"] = pnl
                trade["payout"] = round(trade["cost"] + pnl, 2)
                trade["exit_type"] = iv.exit_reason
                # Bankroll was already credited in _sell_position

                would_have_won = trade["side"] == winner
                result = "WIN" if won else "LOSS"
                held_result = "would've WON" if would_have_won else "would've LOST"
                print(f"  << {result} ({iv.exit_reason}) | P&L ${pnl:+.2f} | {held_result} if held | Bank ${self.bankroll:.2f}")
            else:
                # Held to resolution. Include realized partial exits, then settle
                # remaining shares at binary resolution.
                entry_shares = float(trade.get("entry_shares", trade.get("shares", 0.0)))
                open_shares = float(trade.get("open_shares", trade.get("shares", 0.0)))
                avg_entry_price = (trade["cost"] / entry_shares) if entry_shares > 0 else trade["entry_price"]
                realized_pnl = float(trade.get("realized_pnl", 0.0))
                realized_proceeds = float(trade.get("realized_proceeds", 0.0))

                won = trade["side"] == winner
                unresolved_payout = open_shares if won else 0.0
                unresolved_cost = open_shares * avg_entry_price
                pnl = realized_pnl + (unresolved_payout - unresolved_cost)
                self.bankroll += unresolved_payout

                trade["won"] = won
                trade["pnl"] = round(pnl, 2)
                trade["payout"] = round(realized_proceeds + unresolved_payout, 2)
                trade["exit_type"] = "resolution"

                result = "WIN" if won else "LOSS"
                print(f"  << {result} | {trade['side']} | BTC {trade['final_move']:+.3f}% | P&L ${pnl:+.2f} | Bank ${self.bankroll:.2f} | {sum(1 for t in self.trades if t.get('won'))}/{len(self.trades)}")

            self.trades.append(trade)
            save_state(self.trades, self.bankroll)

            # Track session P&L and check circuit breaker
            self.session_pnl += pnl
            if self.session_pnl <= -self.max_session_loss and not self._circuit_breaker:
                self._circuit_breaker = True
                print(f"  *** CIRCUIT BREAKER *** Session P&L ${self.session_pnl:+.2f} hit max loss ${-self.max_session_loss:.2f} — no more trades", flush=True)
                log_event("circuit_breaker", {"session_pnl": self.session_pnl, "max_loss": self.max_session_loss})

            log_event("resolve", {
                "slug": trade["slug"], "won": won, "pnl": pnl,
                "bankroll": self.bankroll, "winner": winner,
                "exit_type": trade.get("exit_type"),
                "order_id": trade.get("order_id"),
                "session_pnl": self.session_pnl,
            })

            if self._single:
                self._resolved = True
                self.feed.stop()
                print("\n  Single trade complete. Stopping.", flush=True)

        except Exception as e:
            log_event("error", {"context": "resolve", "error": str(e)})

    async def _fetch_market(self, slug):
        url = f"{GAMMA_API}/markets"
        try:
            async with self._http.get(url, params={"slug": slug}, timeout=aiohttp.ClientTimeout(total=10)) as resp:
                if resp.status != 200:
                    return None
                data = await resp.json()
                return data[0] if data else None
        except Exception:
            return None

    async def run(self):
        # Verify credentials
        missing = []
        if not POLY_API_KEY: missing.append("POLY_API_KEY")
        if not POLY_API_SECRET: missing.append("POLY_API_SECRET")
        if not POLY_API_PASSPHRASE: missing.append("POLY_API_PASSPHRASE")
        if not POLY_PRIVATE_KEY: missing.append("POLY_PRIVATE_KEY")
        if missing:
            print(f"FATAL: Missing credentials: {', '.join(missing)}")
            print("Set them in .env or as environment variables.")
            return

        wins = sum(1 for t in self.trades if t.get("won"))
        mode = "AUDIT" if self._audit else "LIVE"
        print(f"{mode} Trader | BTC 15-Min | ${self.bankroll:.2f} | {wins}/{len(self.trades)} trades")
        print(f"Price feed: {self._feed_name} (set PRICE_FEED=binance to override)")
        print(f"Strategy: Calibrated fair values + HTF EMA + TEMA exit")
        print(f"Bet: ${self.bet_size} | Min move: {self.min_move_pct}% | Window: {self.entry_window[0]}-{self.entry_window[1]}s")
        print(f"Edge: >= {self.min_edge} | Max price: {self.max_entry_price}")
        print(f"Entry filter: HTF EMA(5) on 15m candles")
        print(f"Exit: Target sell @ {self.exit_target_price} | Forced @ {self.exit_before_end}s before end | Monitor every {self.monitor_interval}s")
        print(f"TEMA exit: 1m TEMA(5)/TEMA(12) cross after {EXIT_MONITOR_START}s | cushion skip > {EXIT_CUSHION_PCT}%")
        print(f"Order fills: entry timeout {self.entry_order_timeout:.0f}s | exit timeout {self.exit_order_timeout:.0f}s")
        print(f"Risk: Max session loss ${self.max_session_loss:.0f} | Max spread: {self.max_spread:.2f}")
        print(f"Logs: {TRADES_CSV}")
        print(f"*** REAL MONEY MODE ***")
        if not self._log_and_check_funder():
            return
        self._log_balance()

        # Bootstrap indicators
        ok = await self.trend.bootstrap()
        if not ok:
            print("[WARN] TEMA bootstrap failed -- trend data unavailable for logging", flush=True)
        else:
            td = self.trend.get_detail()
            print(f"TEMA (diagnostics): TEMA({self.trend.fast_period}/{self.trend.slow_period}) on "
                  f"{self.trend.candle_interval // 60}min candles | {td['trend']}", flush=True)

        ok = await self.htf_ema.bootstrap()
        if not ok:
            print("[WARN] HTF EMA bootstrap failed -- filter will allow all entries until ready", flush=True)
        else:
            htf_d = self.htf_ema.get_detail()
            print(f"HTF EMA({self.htf_ema.ema_period}) on {self.htf_ema.candle_interval // 60}m: "
                  f"${htf_d['ema_value']:,.2f} | price ${htf_d['price']:,.2f} | {htf_d['direction']}", flush=True)

        ok = await self.exit_tema.bootstrap()
        if not ok:
            print("[WARN] Exit TEMA bootstrap failed -- exit signals disabled until enough 1m candles", flush=True)
        else:
            ed = self.exit_tema.get_detail()
            print(f"Exit TEMA(5/12) on 1m: TEMA(5)=${ed['tema_fast']:,.2f} TEMA(12)=${ed['tema_slow']:,.2f} | {ed['trend']}", flush=True)

        try:
            await self.feed.start()
        finally:
            if self._http and not self._http.closed:
                await self._http.close()

    def _apply_audit_overrides(self):
        # Intentionally permissive to guarantee a single live fill quickly.
        # Min $5 bet to stay above Polymarket's $1 minimum order value at any price.
        self.bet_size = _env_float("AUDIT_BET_SIZE", 5.0)
        self.min_move_pct = _env_float("AUDIT_MIN_MOVE_PCT", 0.0)
        self.entry_window = (
            _env_int("AUDIT_ENTRY_START", 30),
            _env_int("AUDIT_ENTRY_END", 840),
        )
        self.min_edge = _env_float("AUDIT_MIN_EDGE", 0.0)
        self.max_entry_price = _env_float("AUDIT_MAX_ENTRY_PRICE", 0.98)
        # Audit exits — lower target for faster round trip
        self.exit_target_price = _env_float("AUDIT_EXIT_TARGET_PRICE", 0.80)
        self.exit_before_end = _env_int("AUDIT_EXIT_BEFORE_END", 30)
        self.monitor_interval = _env_int("AUDIT_MONITOR_INTERVAL", 2)
        self.entry_order_timeout = _env_float("AUDIT_ENTRY_ORDER_TIMEOUT", self.entry_order_timeout)
        self.exit_order_timeout = _env_float("AUDIT_EXIT_ORDER_TIMEOUT", self.exit_order_timeout)

    def summary(self):
        wins = sum(1 for t in self.trades if t.get("won"))
        total_pnl = sum(t.get("pnl", 0) for t in self.trades)
        print(f"\n=== LIVE Summary: {wins}/{len(self.trades)} wins | P&L ${total_pnl:+.2f} | Bank ${self.bankroll:.2f} ===")


if __name__ == "__main__":
    import sys
    single = "--single" in sys.argv
    audit = "--audit" in sys.argv
    if audit:
        single = True
    trader = LiveTrader(single=single, audit=audit)
    if audit:
        print("*** AUDIT MODE — single trade with permissive thresholds ***", flush=True)
    elif single:
        print("*** SINGLE TRADE MODE — will exit after one round trip ***", flush=True)
    try:
        asyncio.run(trader.run())
    except KeyboardInterrupt:
        print("\nShutting down...")
    except Exception as e:
        msg = traceback.format_exc()
        print(f"\n[FATAL] {msg}")
        log_event("fatal", {"error": str(e), "traceback": msg})
    trader.summary()
